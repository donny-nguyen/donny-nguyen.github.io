# RTK Query

RTK Query is a powerful data-fetching and caching tool built into Redux Toolkit that streamlines how you interact with APIs in your React apps. Here's a breakdown tailored to your programming style:

### 🚀 What RTK Query Does
- **Simplifies API calls**: No more writing reducers, action creators, or thunk logic manually.
- **Auto-generates hooks**: You get custom React hooks like `useGetPostsQuery` or `useAddPostMutation` for each endpoint.
- **Handles caching**: Automatically caches responses and manages cache invalidation.
- **Tracks loading & error states**: Built-in support for `isLoading`, `isError`, etc., right in your components.

### 🧠 Core Concepts
- `createApi()`: The heart of RTK Query. You define your API slice here.
- `fetchBaseQuery()`: A lightweight wrapper around `fetch` for making requests.
- **Endpoints**: Define queries (GET) and mutations (POST, PUT, DELETE) with builder functions.
- **TransformResponse**: Customize how data is shaped before it hits your components.

### 🛠️ Example Setup
```ts
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';

export const apiSlice = createApi({
  reducerPath: 'api',
  baseQuery: fetchBaseQuery({ baseUrl: '/api' }),
  endpoints: (builder) => ({
    getPosts: builder.query<Post[], void>({
      query: () => '/posts',
    }),
    addPost: builder.mutation<Post, Partial<Post>>({
      query: (newPost) => ({
        url: '/posts',
        method: 'POST',
        body: newPost,
      }),
    }),
  }),
});

export const { useGetPostsQuery, useAddPostMutation } = apiSlice;
```

### 🧩 Advanced Features
- **Optimistic updates**: Update UI before server confirms.
- **Streaming updates**: Handle real-time data changes.
- **Tag-based cache invalidation**: Fine-grained control over when data should refetch.

RTK Query is especially handy for scalable apps with complex data flows—something you're clearly building toward.